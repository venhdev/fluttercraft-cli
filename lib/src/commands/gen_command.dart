import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:path/path.dart' as p;

import '../core/helpers/environment_detectors.dart';
import '../core/pubspec_parser.dart';
import '../utils/command_logger.dart';
import '../utils/console.dart';

/// Command to generate fluttercraft.yaml configuration file
class GenCommand extends Command<int> {
  final Console console;

  GenCommand({Console? console}) : console = console ?? Console() {
    argParser.addFlag(
      'force',
      abbr: 'f',
      help: 'Overwrite existing fluttercraft.yaml',
      negatable: false,
    );
  }

  @override
  String get name => 'gen';

  @override
  String get description => 'Generate fluttercraft.yaml configuration file';

  @override
  Future<int> run() async {
    final force = argResults?['force'] == true;
    final projectRoot = Directory.current.path;
    final configPath = p.join(projectRoot, 'fluttercraft.yaml');
    final configFile = File(configPath);

    final logger = CommandLogger(projectRoot: projectRoot, commandName: 'gen');
    await logger.startSession();
    logger.info('Starting config generation');
    logger.info('Project root: $projectRoot');
    logger.info('Config path: $configPath');

    // Check if file exists
    if (await configFile.exists()) {
      if (!force) {
        console.warning('fluttercraft.yaml already exists.');
        console.info('Use --force to overwrite.');
        logger.warning('fluttercraft.yaml already exists. Force not enabled.');
        await logger.endSession(success: false);
        return 1;
      }
      logger.info('Overwriting existing fluttercraft.yaml');
    }

    // Load pubspec to get app name (for reference only)
    final pubspecParser = PubspecParser(projectRoot: projectRoot);
    await pubspecParser.parse();

    // Detect FVM version from .fvmrc
    final fvmVersion = EnvironmentDetectors.detectFvmVersion(projectRoot);

    // Detect Shorebird app_id from shorebird.yaml
    final shorebirdAppId = EnvironmentDetectors.detectShorebirdAppId(projectRoot);

    // Generate config content
    final content = _generateConfigContent(
      fvmVersion: fvmVersion,
      shorebirdAppId: shorebirdAppId,
    );

    // Write file
    await configFile.writeAsString(content);

    // Update .gitignore to include .fluttercraft/
    await _updateGitignore(projectRoot, logger);

    console.success('Generated fluttercraft.yaml');
    console.info('Location: $configPath');
    console.info('Log: ${logger.logFilePath}');
    
    await logger.endSession(success: true);
    return 0;
  }

  /// Update .gitignore to include .fluttercraft/ if not already present
  Future<void> _updateGitignore(String projectRoot, CommandLogger logger) async {
    final gitignorePath = p.join(projectRoot, '.gitignore');
    final gitignoreFile = File(gitignorePath);

    const fluttercraftEntry = '.fluttercraft/';

    if (await gitignoreFile.exists()) {
      final content = await gitignoreFile.readAsString();
      
      // Check if .fluttercraft/ is already in .gitignore
      if (!content.contains(fluttercraftEntry)) {
        // Ask user if they want to add it
        final shouldAdd = console.confirm(
          'Should I add $fluttercraftEntry to .gitignore?',
          defaultValue: true,
        );

        if (shouldAdd) {
          // Append to existing .gitignore
          final newContent = content.endsWith('\n') 
              ? '$content\n# FlutterCraft build output\n$fluttercraftEntry\n'
              : '$content\n\n# FlutterCraft build output\n$fluttercraftEntry\n';
          await gitignoreFile.writeAsString(newContent);
          console.info('Updated .gitignore with $fluttercraftEntry');
          logger.info('Updated .gitignore with $fluttercraftEntry');
        } else {
          console.warning('Skipped updating .gitignore. Please add $fluttercraftEntry manually to avoid committing build artifacts.');
          logger.info('User skipped .gitignore update');
        }
      }
    } else {
      // Ask user if they want to create .gitignore
      final shouldCreate = console.confirm(
        '.gitignore not found. Create it with $fluttercraftEntry?',
        defaultValue: true,
      );

      if (shouldCreate) {
        // Create new .gitignore with .fluttercraft/ entry
        await gitignoreFile.writeAsString(
          '# FlutterCraft build output\n$fluttercraftEntry\n',
        );
        console.info('Created .gitignore with $fluttercraftEntry');
        logger.info('Created .gitignore with $fluttercraftEntry');
      } else {
        console.warning('Skipped creating .gitignore. Please add $fluttercraftEntry manually to avoid committing build artifacts.');
        logger.info('User skipped .gitignore creation');
      }
    }
  }

  String _generateConfigContent({
    String? fvmVersion,
    String? shorebirdAppId,
  }) {
    return '''# fluttercraft.yaml - Build Configuration
# Generated by fluttercraft CLI
#
# App name and version are ALWAYS read from pubspec.yaml
# This file only contains build-specific settings

# ──────────────────────────────────────────────────────────────────────────────
# ROOT KEY (required for all config files)
# ──────────────────────────────────────────────────────────────────────────────
fluttercraft:
  # ════════════════════════════════════════════════════════════════════════════
  # BASE BUILD CONFIGURATION (anchor for inheritance)
  # ════════════════════════════════════════════════════════════════════════════
  build_defaults: &build_defaults
    # Platform: aab | apk | ipa | ios | app
    platform: aab
    # Main entry point
    target: lib/main.dart

    # Extra arguments to pass to the build command (e.g., --obfuscate, --split-debug-info=...)
    args: []

    # ──────────────────────────────────────────────────────────────────────────
    # Dart Define - Always added to build command
    # ──────────────────────────────────────────────────────────────────────────
    global_dart_define: {}

    # Flavor/build-specific dart defines (merged with global)
    dart_define: {}

    # Path to .env or .json file for dart defines (optional)
    # Can be overridden by flavor-specific dart_define_from_file
    # Example: .env, .env.dev, config.json
    dart_define_from_file: null

    # ──────────────────────────────────────────────────────────────────────────
    # Build Flags
    # ──────────────────────────────────────────────────────────────────────────
    flags:
      # Prompt for custom dart-define values during build
      should_prompt_dart_define: false
      # Run flutter clean before build
      should_clean: false
      # Run build_runner before build
      should_build_runner: false

  # ════════════════════════════════════════════════════════════════════════════
  # ACTIVE BUILD CONFIGURATION
  # ════════════════════════════════════════════════════════════════════════════
  build:
    <<: *build_defaults

    # Active flavor: null | dev | staging | prod
    # If set, overrides from flavors section are applied
    flavor: null

  # ════════════════════════════════════════════════════════════════════════════
  # FLAVOR OVERRIDES (NO VERSION OVERRIDES - use dart_define to detect flavor)
  # ════════════════════════════════════════════════════════════════════════════
  # flavors:
  #   dev:
  #     platform: apk
  #     flags:
  #       should_prompt_dart_define: false
  #     dart_define:
  #       FLAVOR: dev
  #       IS_DEV: true
  #       LOG_LEVEL: debug
  #     # Override with flavor-specific env file (optional)
  #     # dart_define_from_file: .env.dev
  #
  #   staging:
  #     platform: aab
  #     flags:
  #       should_prompt_dart_define: false
  #       should_clean: true
  #     dart_define:
  #       FLAVOR: staging
  #       IS_STAGING: true
  #
  #   prod:
  #     platform: aab
  #     flags:
  #       should_prompt_dart_define: false
  #       should_clean: true
  #       should_build_runner: true
  #     dart_define:
  #       FLAVOR: prod
  #       IS_PROD: true

  # ════════════════════════════════════════════════════════════════════════════
  # ENVIRONMENT TOOLS (global only - not overridable by flavors)
  # ════════════════════════════════════════════════════════════════════════════
  environments:
    # FVM integration
    fvm:
      enabled: ${fvmVersion != null ? 'true' : 'false'}
      # Pinned Flutter version (auto-detected from .fvmrc if null)
      version: ${fvmVersion ?? 'null'}

    # Shorebird integration
    shorebird:
      enabled: ${shorebirdAppId != null ? 'true' : 'false'}
      # App ID (auto-detected from shorebird.yaml)
      app_id: ${shorebirdAppId ?? 'null'}
      # @read-only [build:platform] - Artifact type derived from build.platform
      artifact: null
      # Skip confirmation prompts (maps to --no-confirm)
      no_confirm: true

    # Bundletool (AAB → APK conversion)
    bundletool:
      # Path to bundletool.jar (optional)
      path: null
      # Path to key.properties file
      keystore: android/key.properties

    # Disable colors in console output
    no_color: false

  # ════════════════════════════════════════════════════════════════════════════
  # OUTPUT PATHS
  # ════════════════════════════════════════════════════════════════════════════
  paths:
    # Note: if flavor is set, output becomes .fluttercraft/dist/<flavor>/
    output: .fluttercraft/dist

  # ════════════════════════════════════════════════════════════════════════════
  # CUSTOM COMMAND ALIASES
  # ════════════════════════════════════════════════════════════════════════════
  # alias:
  #   gen-icon:
  #     cmds:
  #       - fvm flutter pub get
  #       - fvm flutter pub run flutter_launcher_icons
  #   brn:
  #     cmds:
  #       - fvm flutter pub get
  #       - fvm flutter packages pub run build_runner build --delete-conflicting-outputs
''';
  }
}
